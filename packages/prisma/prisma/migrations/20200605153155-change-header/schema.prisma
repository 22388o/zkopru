generator client {
  provider = "prisma-client-js"
}

datasource sqlite {
  provider = "sqlite"
  url = "***"
}

//  datasource posgres {
//    provider = "postgres"
//    url = "***"
//  }

model EncryptedWallet {
  id String @id @default(uuid())
  ciphertext String
  iv String
  algorithm String
  keylen Int
  kdf String
  N Int
  r Int
  p Int
  salt String
}

model Keystore {
  address String @id
  pubKey String
  encrypted String // stringified json
}

model Config {
  id String @id @default(uuid())
  networkId Int
  chainId Int
  address String
  txoTreeDepth Int
  withdrawalTreeDepth Int
  nullifierTreeDepth Int
  challengePeriod Int
  minimumStake String
  referenceDepth Int
  maxUtxoPerTree String
  maxWithdrawalPerTree String
  utxoSubTreeDepth Int
  utxoSubTreeSize Int
  withdrawalSubTreeDepth Int
  withdrawalSubTreeSize Int
  chain ZkOPRUChain @relation(fields: [id], references: [id])
}

model ZkOPRUChain {
  id String @id @default(uuid())
  config Config?
  nullifierTree NullifierTree
  // utxoTrees UtxoTree[]
  // withdrawalTrees WithdrawalTree[]
  blocks Block[]
}

model Block {
  hash String @id
  header Header @relation(fields: [hash], references: [hash])
  status Int // NOT_FETCHED = 0 / FETCHED = 1 / PARTIALLY_VERIFEID = 2 / FULLY_VERIFIED = 3 / FINALIZED = 4 / INVALIDATED = 5 / REVERTED = 6
  proposalNum Int
  proposedAt Int
  proposalTx String // tx hash
  proposalData String // stringified json
  bootstrap Bootstrap @relation(fields: [hash], references: [hash])
  chainId String?
  chain ZkOPRUChain? @relation(fields: [chainId], references: [id])
}

model Header {
  hash String @id
  proposer String
  parentBlock String
  metadata String
  fee String
  utxoRoot String
  utxoIndex String
  nullifierRoot String
  withdrawalRoot String
  withdrawalIndex String
  txRoot String
  depositRoot String
  migrationRoot String
}

model Bootstrap {
  hash String @id
  utxoTreeIndex Int
  // utxoBootstrap String[]
  utxoBootstrap String // jsonified arr : sqlite does not support arr
  withdrawalTreeIndex Int
  // withdrawalBootstrap String[]
  withdrawalBootstrap String //jsonified arr : sqlite does not support arr
}

model MassDeposit {
  index String @id
  merged String
  fee String
  blockNumber Int
  includedIn String?
  block Block? @relation(fields: [includedIn], references: [hash])
  deposits Deposit[]
}

model Deposit {
  note String @id
  fee String
  transactionIndex Int
  logIndex Int
  blockNumber Int
  queuedAt String?
  includedIn String?
  massDeposit MassDeposit? @relation(fields: [queuedAt], references: [index])
}

model Nullifier {
  index String @id
  nullified Boolean
  blockHash String
}

model Note {
  hash String @id
  index String?
  eth String?
  pubKey String?
  salt String?
  tokenAddr String?
  erc20Amount String?
  nft String?
  type Int?
  withdrawOutTo String?
  fee String?
  status Int?
  treeId String?
  tree LightTree? @relation(fields: [treeId], references: [id])
}

model TreeNode {
  treeId String
  nodeIndex String
  value String
  // tree UtxoTree @relation(fields: [treeId], references: [id])
  @@id([treeId, nodeIndex])
}

model LightTree {
  id String @id @default(uuid())
  species Int // 0: utxo 1: withdrawal
  treeIndex Int
  zkopru String
  block String?
  // rollup sync data
  start String
  end String
  // rollup snapshot data
  root String
  index String
  siblings String // stringified str[]
  chain ZkOPRUChain @relation(fields: [zkopru], references: [id])
  @@index([species, treeIndex])
}

model NullifierTree {
  id String @id @default(uuid())
  zkopru String
  treeIndex Int @unique
  block String?
  root String
  siblings String // stringified str[]
  chain ZkOPRUChain @relation(fields: [zkopru], references: [id])
}
